// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "../../lib/openzeppelin-contracts@4.3.2/contracts/token/ERC721/ERC721.sol";
import "../../lib/openzeppelin-contracts@4.3.2/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "../../lib/openzeppelin-contracts@4.3.2/contracts/token/ERC721/extensions/ERC721Burnable.sol";
import "../../lib/openzeppelin-contracts@4.3.2/contracts/token/ERC721/extensions/ERC721Pausable.sol";
import "../../lib/openzeppelin-contracts@4.3.2/contracts/access/AccessControlEnumerable.sol";
import "../../lib/openzeppelin-contracts@4.3.2/contracts/utils/Context.sol";

import "../utils/AutoIncrement.sol";


abstract contract RetaNft is
  Context,
  AccessControlEnumerable,
  ERC721Enumerable,
  ERC721Burnable,
  ERC721Pausable
{
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

  using AutoIncrement for AutoIncrement.Counter;

  bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
  bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
  bytes32 public constant EDITOR_ROLE = keccak256("EDITOR_ROLE");

  AutoIncrement.Counter private _tokenIdTracker;

  string private _baseTokenURI;
  uint16 private _allowedTokenAmount;

  /**
    * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the
    * account that deploys the contract.
    *
    * Token URIs will be autogenerated based on `baseURI` and their token IDs.
    * See {ERC721-tokenURI}.
    */
  constructor(
      string memory name,
      string memory symbol,
      string memory baseTokenURI,
      uint16 allowedAmount
  ) ERC721(name, symbol) {
    _tokenIdTracker.set(_baseTokenId());
    _baseTokenURI = baseTokenURI;
    _allowedTokenAmount = allowedAmount;

    _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());

    _setupRole(MINTER_ROLE, _msgSender());
    _setupRole(PAUSER_ROLE, _msgSender());
    _setupRole(EDITOR_ROLE, _msgSender());
  }

  function _baseTokenId() internal view virtual returns (uint256) {
    return 10000;
  }

  function _baseURI() internal view virtual override returns (string memory) {
    return _baseTokenURI;
  }

  function setAllowedTokenNumber(uint16 tokenNumber) public onlyOwner {
    _allowedTokenAmount = tokenNumber;
  }

  function allowedTokenAmount() public view returns (uint16) {
    return _allowedTokenAmount;
  }

  function addMinter(address account) public onlyOwner {
    super.grantRole(MINTER_ROLE, account);
  }

  function removeMinter(address account) public onlyOwner {
    super.revokeRole(MINTER_ROLE, account);
  }

  function renounceMinter() public onlyMinter {
    super.renounceRole(MINTER_ROLE, _msgSender());
  }

  function addEditor(address account) public onlyOwner {
    super.grantRole(EDITOR_ROLE, account);
  }

  function removeEditor(address account) public onlyOwner {
    super.revokeRole(EDITOR_ROLE, account);
  }

  function renounceEditor() public onlyEditor {
    super.renounceRole(EDITOR_ROLE, _msgSender());
  }

  modifier onlyMinter() {
    require(hasRole(MINTER_ROLE, _msgSender()), "RetaNft: must have minter role to mint");
    _;
  }

  modifier onlyPauser() {
    require(hasRole(PAUSER_ROLE, _msgSender()), "RetaNft: must have pauser role to pause");
    _;
  }

  modifier onlyEditor() {
    require(hasRole(EDITOR_ROLE, _msgSender()), "RetaNft: must have editor role to edit");
    _;
  }

  modifier validToken(uint256 tokenId) {
    require(_exists(tokenId), "RetaNft: invalid token id");
    _;
  }

  /**
    * @dev Creates a new token for `to`. Its token ID will be automatically
    * assigned (and available on the emitted {IERC721-Transfer} event), and the token
    * URI autogenerated based on the base URI passed at construction.
    *
    * See {ERC721-_mint}.
    *
    * Requirements:
    *
    * - the caller must have the `MINTER_ROLE`.
    */
  function mint(address to) internal returns (uint256 tokenId) {
    // We cannot just use balanceOf to create the new tokenId because tokens
    // can be burned (destroyed), so we need a separate counter.
    tokenId = _tokenIdTracker.current();
    _mint(to, tokenId);
    _tokenIdTracker.increment();

    return tokenId;
  }

  function nextTokenId() internal view returns (uint256 tokenId) {
    return _tokenIdTracker.current();
  }

  /**
    * @dev Pauses all token transfers.
    *
    * See {ERC721Pausable} and {Pausable-_pause}.
    *
    * Requirements:
    *
    * - the caller must have the `PAUSER_ROLE`.
    */
  function pause() public virtual onlyPauser {
    _pause();
  }

  /**
    * @dev Unpauses all token transfers.
    *
    * See {ERC721Pausable} and {Pausable-_unpause}.
    *
    * Requirements:
    *
    * - the caller must have the `PAUSER_ROLE`.
    */
  function unpause() public virtual onlyPauser {
    _unpause();
  }

  function _beforeTokenTransfer(
    address from,
    address to,
    uint256 tokenId
  ) internal virtual override(ERC721, ERC721Enumerable, ERC721Pausable) {
    if(to != address(0) && to != owner()) {
      require(balanceOf(to) < _allowedTokenAmount, "RetaNft: cannot have more by the limitation");
    }

    super._beforeTokenTransfer(from, to, tokenId);
  }

  /**
    * @dev See {IERC165-supportsInterface}.
    */
  function supportsInterface(bytes4 interfaceId)
    public
    view
    virtual
    override(AccessControlEnumerable, ERC721, ERC721Enumerable)
    returns (bool)
  {
    return super.supportsInterface(interfaceId);
  }

  function owner() public view virtual returns (address) {
    return getRoleMember(DEFAULT_ADMIN_ROLE, 0);
  }

  modifier onlyOwner() {
    require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), "RetaNft: caller is not owner");
    _;
  }

  function transferOwnership(address newOwner) public virtual onlyOwner {
    require(newOwner != address(0), "RetaNft: new owner is the zero address");
    _setOwner(newOwner);
  }

  function _setOwner(address newOwner) private {
    address oldOwner = owner();
    super.grantRole(DEFAULT_ADMIN_ROLE, newOwner);
    super.revokeRole(DEFAULT_ADMIN_ROLE, oldOwner);
    emit OwnershipTransferred(oldOwner, newOwner);
  }
}
